
OpenSSF Best Practices
StandWithUkraine
Projects that follow the best practices below can voluntarily self-certify and show that they've achieved an Open Source Security Foundation (OpenSSF) best practices badge. 

There is no set of practices that can guarantee that software will never have defects or vulnerabilities; even formal methods can fail if the specifications or assumptions are wrong. Nor is there any set of practices that can guarantee that a project will sustain a healthy and well-functioning development community. However, following best practices can help improve the results of projects. For example, some practices enable multi-person review before release, which can both help find otherwise hard-to-find technical vulnerabilities and help build trust and a desire for repeated interaction among developers from different companies. To earn a badge, all MUST and MUST NOT criteria must be met, all SHOULD criteria must be met OR be unmet with justification, and all SUGGESTED criteria must be met OR unmet (we want them considered at least). If you want to enter justification text as a generic comment, instead of being a rationale that the situation is acceptable, start the text block with '//' followed by a space. Feedback is welcome via the GitHub site as issues or pull requests There is also a mailing list for general discussion.

We gladly provide the information in several locales, however, if there is any conflict or inconsistency between the translations, the English version is the authoritative version.
If this is your project, please show your badge status on your project page! The badge status looks like this: Badge level for project 7646 is in_progress Here is how to embed it: 
You can show your badge status by embedding this in your markdown file:
[![OpenSSF Best Practices](https://www.bestpractices.dev/projects/7646/badge)](https://www.bestpractices.dev/projects/7646)
or by embedding this in your HTML:
<a href="https://www.bestpractices.dev/projects/7646"><img src="https://www.bestpractices.dev/projects/7646/badge"></a>


These are the Passing level criteria. You can also view the Silver or Gold level criteria.

        

 Basics7/13 ●
Identification
What is the human-readable name of the project? 
Note that other projects may use the same name.
StandWithUkraine
What is a brief description of the project?
#StandWithUkraine banner and related documents

What is the URL for the project (as a whole)?
https://stand-with-ukraine.pp.ua
What is the URL for the version control repository (it may be the same as the project URL)?
https://github.com/mmu094/StandWithUkraine
What programming language(s) are used to implement the project? 
If there is more than one language, list them as comma-separated values (spaces optional) and sort them from most to least used. If there is a long list, please list at least the first three most common ones. If there is no language (e.g., this is a documentation-only or test-only project), use the single character "-". Please use a conventional capitalization for each language, e.g., "JavaScript".
Implementation languages
JavaScript
What is the Common Platform Enumeration (CPE) name for the project (if it has one)? 
The Common Platform Enumeration (CPE) is a structured naming scheme for information technology systems, software, and packages. It is used in a number of systems and databases when reporting vulnerabilities.
(Optional) CPE name
Basic project website content

Unknown required information, not enough for a badge.
Met
Unmet
?

The project website MUST succinctly describe what the software does (what problem does it solve?). [description_good] 
This MUST be in language that potential users can understand (e.g., it uses minimal jargon).

Unknown required information, not enough for a badge.
Met
Unmet
?

The project website MUST provide information on how to: obtain, provide feedback (as bug reports or enhancements), and contribute to the software. [interact]

Enough for a badge!
Met
Unmet
?

The information on how to contribute MUST explain the contribution process (e.g., are pull requests used?) (URL required) [contribution] 
We presume that projects on GitHub use issues and pull requests unless otherwise noted. This information can be short, e.g., stating that the project uses pull requests, an issue tracker, or posts to a mailing list (which one?)
Projects on GitHub by default use issues and pull requests, as encouraged by documentation such as https://guides.github.com/activities/contributing-to-open-source/.


Unknown required information, not enough for a badge.
Met
Unmet
?

The information on how to contribute SHOULD include the requirements for acceptable contributions (e.g., a reference to any required coding standard). (URL required) [contribution_requirements]
FLOSS license
What license(s) is the project released under? 
Please use SPDX license expression format; examples include "Apache-2.0", "BSD-2-Clause", "BSD-3-Clause", "GPL-2.0+", "LGPL-3.0+", "MIT", and "(BSD-2-Clause OR Ruby)". Do not include single quotes or double quotes.
License
CC0-1.0


Unknown required information, not enough for a badge.
Met
Unmet
?

The software produced by the project MUST be released as FLOSS. [floss_license] 
FLOSS is software released in a way that meets the Open Source Definition or Free Software Definition. Examples of such licenses include the CC0, MIT, BSD 2-clause, BSD 3-clause revised, Apache 2.0, Lesser GNU General Public License (LGPL), and the GNU General Public License (GPL). For our purposes, this means that the license MUST be:
an approved license by the Open Source Initiative (OSI), or
a free license as approved by the Free Software Foundation (FSF), or
a free license acceptable to Debian main, or
a "good" license according to Fedora.
The software MAY also be licensed other ways (e.g., "GPLv2 or proprietary" is acceptable).

Barely enough for a badge.
Met
Unmet
?

It is SUGGESTED that any required license(s) for the software produced by the project be approved by the Open Source Initiative (OSI). [floss_license_osi] 
The OSI uses a rigorous approval process to determine which licenses are OSS.
// Did not find license in the OSI list.


Enough for a badge!
Met
Unmet
?

The project MUST post the license(s) of its results in a standard location in their source repository. (URL required) [license_location] 
One convention is posting the license as a top-level file named LICENSE or COPYING, which MAY be followed by an extension such as ".txt" or ".md". An alternative convention is to have a directory named LICENSES containing license file(s); these files are typically named as their SPDX license identifier followed by an appropriate file extension, as described in the REUSE Specification. Note that this criterion is only a requirement on the source repository. You do NOT need to include the license file when generating something from the source code (such as an executable, package, or container). For example, when generating an R package for the Comprehensive R Archive Network (CRAN), follow standard CRAN practice: if the license is a standard license, use the standard short license specification (to avoid installing yet another copy of the text) and list the LICENSE file in an exclusion file such as .Rbuildignore. Similarly, when creating a Debian package, you may put a link in the copyright file to the license text in /usr/share/common-licenses, and exclude the license file from the created package (e.g., by deleting the file after calling dh_auto_install). We encourage including machine-readable license information in generated formats where practical.
Non-trivial license location file in repository: https://github.com/mmu094/StandWithUkraine/blob/main/LICENSE.


Documentation

Enough for a badge!
Met
Unmet
N/A
?

The project MUST provide basic documentation for the software produced by the project. [documentation_basics] 
This documentation must be in some media (such as text or video) that includes: how to install it, how to start it, how to use it (possibly with a tutorial using examples), and how to use it securely (e.g., what to do and what not to do) if that is an appropriate topic for the software. The security documentation need not be long. The project MAY use hypertext links to non-project material as documentation. If the project does not produce software, choose "not applicable" (N/A).
Some documentation basics file contents found.


Unknown required information, not enough for a badge.
Met
Unmet
N/A
?

The project MUST provide reference documentation that describes the external interface (both input and output) of the software produced by the project. [documentation_interface] 
The documentation of an external interface explains to an end-user or developer how to use it. This would include its application program interface (API) if the software has one. If it is a library, document the major classes/types and methods/functions that can be called. If it is a web application, define its URL interface (often its REST interface). If it is a command-line interface, document the parameters and options it supports. In many cases it's best if most of this documentation is automatically generated, so that this documentation stays synchronized with the software as it changes, but this isn't required. The project MAY use hypertext links to non-project material as documentation. Documentation MAY be automatically generated (where practical this is often the best way to do so). Documentation of a REST interface may be generated using Swagger/OpenAPI. Code interface documentation MAY be generated using tools such as JSDoc (JavaScript), ESDoc (JavaScript), pydoc (Python), devtools (R), pkgdown (R), and Doxygen (many). Merely having comments in implementation code is not sufficient to satisfy this criterion; there needs to be an easy way to see the information without reading through all the source code. If the project does not produce software, choose "not applicable" (N/A).

Other

Enough for a badge!
Met
Unmet
?

The project sites (website, repository, and download URLs) MUST support HTTPS using TLS. [sites_https] 
This requires that the project home page URL and the version control repository URL begin with "https:", not "http:". You can get free certificates from Let's Encrypt. Projects MAY implement this criterion using (for example) GitHub pages, GitLab pages, or SourceForge project pages. If you support HTTP, we urge you to redirect the HTTP traffic to HTTPS.
Given only https: URLs.


Enough for a badge!
Met
Unmet
?

The project MUST have one or more mechanisms for discussion (including proposed changes and issues) that are searchable, allow messages and topics to be addressed by URL, enable new people to participate in some of the discussions, and do not require client-side installation of proprietary software. [discussion] 
Examples of acceptable mechanisms include archived mailing list(s), GitHub issue and pull request discussions, Bugzilla, Mantis, and Trac. Asynchronous discussion mechanisms (like IRC) are acceptable if they meet these criteria; make sure there is a URL-addressable archiving mechanism. Proprietary JavaScript, while discouraged, is permitted.
GitHub supports discussions on issues and pull requests.


Unknown required information, not enough for a badge.
Met
Unmet
?

The project SHOULD provide documentation in English and be able to accept bug reports and comments about code in English. [english] 
English is currently the lingua franca of computer technology; supporting English increases the number of different potential developers and reviewers worldwide. A project can meet this criterion even if its core developers' primary language is not English.

Enough for a badge!
Met
Unmet
?

The project MUST be maintained. [maintained] 
As a minimum, the project should attempt to respond to significant problem and vulnerability reports. A project that is actively pursuing a badge is probably maintained. All projects and people have limited resources, and typical projects must reject some proposed changes, so limited resources and proposal rejections do not by themselves indicate an unmaintained project.

When a project knows that it will no longer be maintained, it should set this criterion to "Unmet" and use the appropriate mechanism(s) to indicate to others that it is not being maintained. For example, use “DEPRECATED” as the first heading of its README, add “DEPRECATED” near the beginning of its home page, add “DEPRECATED” to the beginning of its code repository project description, add a no-maintenance-intended badge in its README and/or home page, mark it as deprecated in any package repositories (e.g., npm deprecate), and/or use the code repository's marking system to archive it (e.g., GitHub's "archive" setting, GitLab’s "archived" marking, Gerrit's "readonly" status, or SourceForge’s "abandoned" project status). Additional discussion can be found here.


(Advanced) Disable inactivity reminder (we recommend you leave this unchecked; note that project entries must be edited to change whether or not reminders are sent)
(Advanced) What other users have additional rights to edit this badge entry? Currently: [] 
Most projects should ignore this field. Project badge entries can always be edited by the badge entry owner (creator), BadgeApp administrators, and anyone who can commit to the GitHub repository (if it's on GitHub). If you want someone else to be able to edit this badge entry, and you already have edit rights to this project badge entry, you can additional users with edit rights. Just enter "+" followed by a comma-separated list of integer user ids. Those users will then also be allowed to edit this project entry. If you're the owner of the badge entry or a BadgeApp administrator, you can remove users from this list by entering "-" followed by a comma-separated list of integer user ids. We expect that normally only one person will edit a particular badge entry at a time. This application uses optimistic locking to prevent saving stale data if multiple users try to edit a badge entry simultaneously. If you have multiple editors, we recommend saving badge entry data incrementally and often (that is a wise practice anyway).


Other general comments about the project:
 Change Control3/9 ●
Public version-controlled source repository

Enough for a badge!
Met
Unmet
?

The project MUST have a version-controlled source repository that is publicly readable and has a URL. [repo_public] 
The URL MAY be the same as the project URL. The project MAY use private (non-public) branches in specific cases while the change is not publicly released (e.g., for fixing a vulnerability before it is revealed to the public).
Repository on GitHub, which provides public git repositories with URLs.


Enough for a badge!
Met
Unmet
?

The project's source repository MUST track what changes were made, who made the changes, and when the changes were made. [repo_track]
Repository on GitHub, which uses git. git can track the changes, who made them, and when they were made.


Unknown required information, not enough for a badge.
Met
Unmet
?

To enable collaborative review, the project's source repository MUST include interim versions for review between releases; it MUST NOT include only final releases. [repo_interim] 
Projects MAY choose to omit specific interim versions from their public source repositories (e.g., ones that fix specific non-public security vulnerabilities, may never be publicly released, or include material that cannot be legally posted and are not in the final release).

Enough for a badge!
Met
Unmet
?

It is SUGGESTED that common distributed version control software be used (e.g., git) for the project's source repository. [repo_distributed] 
Git is not specifically required and projects can use centralized version control software (such as subversion) with justification.
Repository on GitHub, which uses git. git is distributed.


Unique version numbering

Unknown required information, not enough for a badge.
Met
Unmet
?

The project results MUST have a unique version identifier for each release intended to be used by users. [version_unique] 
This MAY be met in a variety of ways including a commit IDs (such as git commit id or mercurial changeset id) or a version number (including version numbers that use semantic versioning or date-based schemes like YYYYMMDD).

Unknown required information, not enough for a badge.
Met
Unmet
?

It is SUGGESTED that the Semantic Versioning (SemVer) or Calendar Versioning (CalVer) version numbering format be used for releases. It is SUGGESTED that those who use CalVer include a micro level value. [version_semver] 
Projects should generally prefer whatever format is expected by their users, e.g., because it is the normal format used by their ecosystem. Many ecosystems prefer SemVer, and SemVer is generally preferred for application programmer interfaces (APIs) and software development kits (SDKs). CalVer tends to be used by projects that are large, have an unusually large number of independently-developed dependencies, have a constantly-changing scope, or are time-sensitive. It is SUGGESTED that those who use CalVer include a micro level value, because including a micro level supports simultaneously-maintained branches whenever that becomes necessary. Other version numbering formats may be used as version numbers, including git commit IDs or mercurial changeset IDs, as long as they uniquely identify versions. However, some alternatives (such as git commit IDs) can cause problems as release identifiers, because users may not be able to easily determine if they are up-to-date. The version ID format may be unimportant for identifying software releases if all recipients only run the latest version (e.g., it is the code for a single website or internet service that is constantly updated via continuous delivery).

Unknown required information, not enough for a badge.
Met
Unmet
?

It is SUGGESTED that projects identify each release within their version control system. For example, it is SUGGESTED that those using git identify each release using git tags. [version_tags]
Release notes

Not enough for a badge.
Me
Unmet
N/A
?

The project MUST provide, in each release, release notes that are a human-readable summary of major changes in that release to help users determine if they should upgrade and what the upgrade impact will be. The release notes MUST NOT be the raw output of a version control log (e.g., the "git log" command results are not release notes). Projects whose results are not intended for reuse in multiple locations (such as the software for a single website or service) AND employ continuous delivery MAY select "N/A". (URL required) [release_notes] 
The release notes MAY be implemented in a variety of ways. Many projects provide them in a file named "NEWS", "CHANGELOG", or "ChangeLog", optionally with extensions such as ".txt", ".md", or ".html". Historically the term "change log" meant a log of every change, but to meet these criteria what is needed is a human-readable summary. The release notes MAY instead be provided by version control system mechanisms such as the GitHub Releases workflow.
// No release notes file found.


Unknown required information, not enough for a badge.
Met
Unmet
N/A
?

The release notes MUST identify every publicly known run-time vulnerability fixed in this release that already had a CVE assignment or similar when the release was created. This criterion may be marked as not applicable (N/A) if users typically cannot practically update the software themselves (e.g., as is often true for kernel updates). This criterion applies only to the project results, not to its dependencies. If there are no release notes or there have been no publicly known vulnerabilities, choose N/A. [release_notes_vulns] 
This criterion helps users determine if a given update will fix a vulnerability that is pub
